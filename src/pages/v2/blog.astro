---
import V2Layout from '@/layouts/V2Layout.astro';
import V2Header from '@/components/v2/V2Header.astro';
import V2Footer from '@/components/v2/V2Footer.astro';
---

<V2Layout title="Blog • Dipankar Shaw">
  <!-- Page wrapper -->
  <div class="mx-auto flex min-h-screen max-w-6xl flex-col gap-10 px-4 pb-16 pt-6 sm:px-6 lg:px-8 lg:pt-10">
    <!-- NAVBAR -->
    <V2Header currentPage="blog" />

    <!-- MAIN -->
    <main class="flex flex-1 flex-col gap-8">
      <!-- Page header -->
      <section class="space-y-3">
        <div class="inline-flex items-center gap-2 rounded-full border border-teal-400/40 bg-slate-900/80 px-3 py-1 text-[0.7rem] font-medium text-teal-200 shadow-sm shadow-teal-500/40">
          <span class="inline-flex h-1.5 w-1.5 rounded-full bg-teal-400"></span>
          <span>Blog • Learning in public</span>
        </div>
        <div>
          <h1 class="text-4xl font-semibold tracking-tight text-slate-50 sm:text-5xl" style="font-family: 'Space Grotesk', system-ui, sans-serif;">
            Notes from the journey
          </h1>
          <p class="mt-2 max-w-2xl text-base leading-relaxed text-slate-300 sm:text-lg">
            Short, focused posts on full stack development, PWAs, Vim / Neovim, and building products that feel fast.
          </p>
        </div>
      </section>

      <!-- Layout: list + content -->
      <section class="grid gap-6 lg:grid-cols-[minmax(0,0.9fr)_minmax(0,1.3fr)]">
        <!-- Blog list -->
        <aside class="space-y-4">
          <div class="flex items-center justify-between gap-3">
            <h2 class="text-lg font-semibold tracking-tight text-slate-50" style="font-family: 'Space Grotesk', system-ui, sans-serif;">
              Posts
            </h2>
            <span class="rounded-full bg-slate-900/80 px-3 py-1 text-xs text-slate-300">
              4 articles
            </span>
          </div>

          <div class="space-y-2" id="blog-list">
            <!-- Each blog list item -->
            <button type="button" class="group w-full rounded-2xl border border-slate-800/80 bg-slate-950/80 p-3 text-left transition hover:border-teal-400/70 hover:bg-slate-900/80" data-post-id="blog-1">
              <div class="flex items-center justify-between gap-2">
                <h3 class="text-sm font-medium tracking-tight text-slate-50">
                  Building my first offline‑first PWA
                </h3>
                <span class="rounded-full bg-teal-500/10 px-2 py-0.5 text-[0.65rem] text-teal-200">
                  PWA
                </span>
              </div>
              <p class="mt-1 text-xs text-slate-300">
                A quick breakdown of how I approached caching, sync, and UX.
              </p>
              <div class="mt-2 flex items-center justify-between text-[0.7rem] text-slate-400">
                <span>4 min read</span>
                <span class="inline-flex items-center gap-1 text-teal-300 group-hover:translate-x-0.5 group-hover:text-teal-200 transition">
                  <span>Read</span>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M5 12h14" stroke-linecap="round" stroke-linejoin="round"></path>
                    <path d="m13 6 6 6-6 6" stroke-linecap="round" stroke-linejoin="round"></path>
                  </svg>
                </span>
              </div>
            </button>

            <button type="button" class="group w-full rounded-2xl border border-slate-800/80 bg-slate-950/80 p-3 text-left transition hover:border-teal-400/70 hover:bg-slate-900/80" data-post-id="blog-2">
              <div class="flex items-center justify-between gap-2">
                <h3 class="text-sm font-medium tracking-tight text-slate-50">
                  Why Neovim clicked for me as a beginner
                </h3>
                <span class="rounded-full bg-purple-500/10 px-2 py-0.5 text-[0.65rem] text-purple-200">
                  Neovim
                </span>
              </div>
              <p class="mt-1 text-xs text-slate-300">
                Thoughts on keybindings, focus, and learning curve from my setup.
              </p>
              <div class="mt-2 flex items-center justify-between text-[0.7rem] text-slate-400">
                <span>5 min read</span>
                <span class="inline-flex items-center gap-1 text-teal-300 group-hover:translate-x-0.5 group-hover:text-teal-200 transition">
                  <span>Read</span>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M5 12h14" stroke-linecap="round" stroke-linejoin="round"></path>
                    <path d="m13 6 6 6-6 6" stroke-linecap="round" stroke-linejoin="round"></path>
                  </svg>
                </span>
              </div>
            </button>

            <button type="button" class="group w-full rounded-2xl border border-slate-800/80 bg-slate-950/80 p-3 text-left transition hover:border-teal-400/70 hover:bg-slate-900/80" data-post-id="blog-3">
              <div class="flex items-center justify-between gap-2">
                <h3 class="text-sm font-medium tracking-tight text-slate-50">
                  A tiny API design checklist I use
                </h3>
                <span class="rounded-full bg-cyan-500/10 px-2 py-0.5 text-[0.65rem] text-cyan-200">
                  Backend
                </span>
              </div>
              <p class="mt-1 text-xs text-slate-300">
                Small habits that make my Node / FastAPI endpoints easier to work with.
              </p>
              <div class="mt-2 flex items-center justify-between text-[0.7rem] text-slate-400">
                <span>3 min read</span>
                <span class="inline-flex items-center gap-1 text-teal-300 group-hover:translate-x-0.5 group-hover:text-teal-200 transition">
                  <span>Read</span>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M5 12h14" stroke-linecap="round" stroke-linejoin="round"></path>
                    <path d="m13 6 6 6-6 6" stroke-linecap="round" stroke-linejoin="round"></path>
                  </svg>
                </span>
              </div>
            </button>

            <button type="button" class="group w-full rounded-2xl border border-slate-800/80 bg-slate-950/80 p-3 text-left transition hover:border-teal-400/70 hover:bg-slate-900/80" data-post-id="blog-4">
              <div class="flex items-center justify-between gap-2">
                <h3 class="text-sm font-medium tracking-tight text-slate-50">
                  Shipping small CLI tools for myself
                </h3>
                <span class="rounded-full bg-slate-700/80 px-2 py-0.5 text-[0.65rem] text-slate-200">
                  CLI
                </span>
              </div>
              <p class="mt-1 text-xs text-slate-300">
                How tiny scripts in Node and Python save me time every week.
              </p>
              <div class="mt-2 flex items-center justify-between text-[0.7rem] text-slate-400">
                <span>4 min read</span>
                <span class="inline-flex items-center gap-1 text-teal-300 group-hover:translate-x-0.5 group-hover:text-teal-200 transition">
                  <span>Read</span>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M5 12h14" stroke-linecap="round" stroke-linejoin="round"></path>
                    <path d="m13 6 6 6-6 6" stroke-linecap="round" stroke-linejoin="round"></path>
                  </svg>
                </span>
              </div>
            </button>
          </div>
        </aside>

        <!-- Active blog content -->
        <article id="blog-content" class="rounded-2xl border border-slate-800/80 bg-slate-950/80 p-4 sm:p-5">
          <!-- Default content for first post -->
          <header class="border-b border-slate-800/80 pb-4">
            <div class="flex flex-wrap items-center justify-between gap-3">
              <div>
                <p class="text-[0.7rem] uppercase tracking-[0.18em] text-slate-400">
                  PWA • Product notes
                </p>
                <h2 class="mt-1 text-2xl font-semibold tracking-tight text-slate-50 sm:text-3xl" style="font-family: 'Space Grotesk', system-ui, sans-serif;">
                  Building my first offline‑first PWA
                </h2>
              </div>
              <div class="flex flex-col items-end gap-1 text-right text-[0.7rem] text-slate-400">
                <span>4 min read</span>
                <span>Published · Demo content</span>
              </div>
            </div>
          </header>

          <div class="prose prose-invert mt-4 max-w-none text-base leading-relaxed text-slate-200">
            <p>
              When I started working on my first offline‑first app, I had two goals:
              <span class="text-teal-200">make it feel instant</span> and
              <span class="text-teal-200">avoid data loss</span>. The project was a simple task manager, but I treated it as a chance to learn the core ideas behind PWAs.
            </p>
            <p>
              The biggest mindset shift was realizing that <span class="text-teal-200">the network is a cache</span>, not the source of truth. The app should keep working even if the connection disappears at the worst moment.
            </p>

            <h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">
              Caching the shell first
            </h3>
            <p>
              I started with a classic pattern:
              <span class="text-teal-200">cache the application shell</span> using a service worker. That means HTML, CSS, JS, icons — everything needed to show the UI instantly on repeat visits.
            </p>
            <p>
              In practice this looked like:
            </p>
            <ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
              <li>Pre‑caching the shell on install</li>
              <li>Serving it from cache on every navigation</li>
              <li>Fetching fresh data in the background when possible</li>
            </ul>

            <h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">
              Local database first, then sync
            </h3>
            <p>
              For tasks, I used <span class="text-teal-200">IndexedDB</span> as the local source of truth. The UI always read from there, and a small sync worker took care of pushing changes to the backend whenever the network was available.
            </p>
            <p>
              This separation kept my React components simple: they didn't know if we were online or offline, they just knew how to read and write tasks.
            </p>

            <h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">
              What I'd improve next time
            </h3>
            <p>
              For a first attempt, this was enough. But I'd like to refine:
            </p>
            <ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
              <li>Conflict resolution when two devices edit the same task</li>
              <li>Better visualization of sync state (what's pending vs synced)</li>
              <li>Background sync for more reliable updates</li>
            </ul>
            <p class="mt-3">
              Still, this project convinced me that <span class="text-teal-200">offline‑first isn't just a feature</span>. It's a mindset about respecting users' time and bandwidth, especially on unstable networks.
            </p>
          </div>
        </article>
      </section>
    </main>

    <!-- FOOTER -->
    <V2Footer context="blog" />
  </div>
</V2Layout>

<script>
  // Simple in-page blog routing
  const posts = {
    'blog-1': {
      category: 'PWA • Product notes',
      title: 'Building my first offline‑first PWA',
      meta: '4 min read',
      content: `
<p>
  When I started working on my first offline‑first app, I had two goals:
  <span class="text-teal-200">make it feel instant</span> and
  <span class="text-teal-200">avoid data loss</span>. The project was a simple task manager, but I treated it as a chance to learn the core ideas behind PWAs.
</p>
<p>
  The biggest mindset shift was realizing that <span class="text-teal-200">the network is a cache</span>, not the source of truth. The app should keep working even if the connection disappears at the worst moment.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">Caching the shell first</h3>
<p>
  I started with a classic pattern:
  <span class="text-teal-200">cache the application shell</span> using a service worker. That means HTML, CSS, JS, icons &mdash; everything needed to show the UI instantly on repeat visits.
</p>
<p>In practice this looked like:</p>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li>Pre‑caching the shell on install</li>
  <li>Serving it from cache on every navigation</li>
  <li>Fetching fresh data in the background when possible</li>
</ul>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">Local database first, then sync</h3>
<p>
  For tasks, I used <span class="text-teal-200">IndexedDB</span> as the local source of truth. The UI always read from there, and a small sync worker took care of pushing changes to the backend whenever the network was available.
</p>
<p>
  This separation kept my React components simple: they didn&apos;t know if we were online or offline, they just knew how to read and write tasks.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">What I&apos;d improve next time</h3>
<p>For a first attempt, this was enough. But I&apos;d like to refine:</p>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li>Conflict resolution when two devices edit the same task</li>
  <li>Better visualization of sync state (what&apos;s pending vs synced)</li>
  <li>Background sync for more reliable updates</li>
</ul>
<p class="mt-3">
  Still, this project convinced me that <span class="text-teal-200">offline‑first isn&apos;t just a feature</span>. It&apos;s a mindset about respecting users&apos; time and bandwidth, especially on unstable networks.
</p>
      `
    },
    'blog-2': {
      category: 'Neovim • Workflow',
      title: 'Why Neovim clicked for me as a beginner',
      meta: '5 min read',
      content: `
<p>
  I didn&apos;t expect <span class="text-teal-200">Neovim</span> to be friendly as a beginner. It looked intimidating: no mouse, lots of keybindings, and config files everywhere.
  But once I pushed through the first week, it became my favorite place to write code.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">Modal editing changes how you think</h3>
<p>
  The biggest change was understanding that <span class="text-teal-200">I&apos;m not always typing</span>. Most of the time I&apos;m navigating, selecting, and refactoring.
  Neovim&apos;s normal mode is optimized exactly for that.
</p>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li><code>ciw</code> to change the current word</li>
  <li><code>dap</code> to delete a paragraph</li>
  <li><code>ggVG</code> to select the whole file</li>
</ul>
<p>
  These short sequences started to feel like a little language for editing code. It took a few days, but suddenly the editor felt like an extension of my hands.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">A minimal config to start</h3>
<p>
  I kept my config extremely small:
</p>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li>File tree and fuzzy finder</li>
  <li>LSP and completion for TypeScript / Python</li>
  <li>Basic statusline and colorscheme</li>
</ul>
<p>
  Instead of chasing plugins, I focused on learning motions, registers, and macros. That was the real unlock.
</p>
<p class="mt-3">
  If you&apos;re curious about Neovim, my advice is simple:
  <span class="text-teal-200">commit to 7–10 days</span>. Use it for everything. The first few days are rough, but the payoff is huge.
</p>
      `
    },
    'blog-3': {
      category: 'Backend • API design',
      title: 'A tiny API design checklist I use',
      meta: '3 min read',
      content: `
<p>
  Whenever I create a new endpoint in <span class="text-teal-200">Node</span> or
  <span class="text-teal-200">FastAPI</span>, I try to run through a small mental checklist.
  It&apos;s simple, but it keeps things consistent and easier to maintain.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">1. Name and resource shape</h3>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li>Is the route noun‑based? (<code>/tasks</code>, <code>/projects</code>)</li>
  <li>Does the JSON response mirror real objects in the system?</li>
</ul>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">2. Error handling</h3>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li>Do I return a clear <code>message</code> and <code>code</code> field on errors?</li>
  <li>Can the frontend reliably distinguish user errors from server errors?</li>
</ul>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">3. Pagination and filters</h3>
<p>
  I prefer a very boring pattern:
  <code>?page=1&amp;limit=20</code> with a response that includes
  <code>items</code>, <code>total</code>, and <code>nextPage</code>.
</p>
<p>
  For filters, I start simple:
  <code>?status=done</code>, <code>?q=search</code>. If it grows too complex,
  that&apos;s usually a sign I need a dedicated search endpoint.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">4. Versioning</h3>
<p>
  Even for side projects, I often prefix routes with
  <code>/api/v1</code>. It costs almost nothing and keeps the door open for changes later.
</p>
<p class="mt-3">
  This checklist isn&apos;t perfect, but it keeps me honest. When in doubt,
  I try to design APIs <span class="text-teal-200">I would enjoy using from the frontend</span>.
</p>
      `
    },
    'blog-4': {
      category: 'CLI • Productivity',
      title: 'Shipping small CLI tools for myself',
      meta: '4 min read',
      content: `
<p>
  Some of the most useful things I&apos;ve built aren&apos;t full apps. They&apos;re
  <span class="text-teal-200">tiny CLI tools</span> that save me a few minutes every day.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">Start with a real annoyance</h3>
<p>
  Every useful CLI I wrote started as a repeated annoyance:
</p>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li>Typing the same long git commands</li>
  <li>Manually creating project folders with the same structure</li>
  <li>Checking the same API endpoints during debugging</li>
</ul>
<p>
  Once something annoys me three times, I try to script it.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">Node and Python are enough</h3>
<p>
  Most of my tools are just:
</p>
<ul class="mt-2 list-disc space-y-1 pl-5 text-slate-200">
  <li>A Node script with a small argument parser</li>
  <li>Or a Python script using <code>argparse</code></li>
</ul>
<p>
  I focus on clear flags, colorized output, and good error messages. A pleasant CLI
  can feel surprisingly &quot;premium&quot; even if it&apos;s just for me.
</p>
<h3 class="mt-4 text-lg font-semibold tracking-tight text-slate-50">Why it matters</h3>
<p>
  These tools are where I practice new ideas:
  better logging, small abstractions, packaging, and distribution. They also make my
  day‑to‑day coding feel smoother.
</p>
<p class="mt-3">
  If you&apos;ve never built a CLI, pick one tiny annoyance this week and script it.
  Your future self will thank you.
</p>
      `
    }
  };

  const contentContainer = document.getElementById('blog-content');

  function renderPost(id: string) {
    const post = posts[id];
    if (!post || !contentContainer) return;

    contentContainer.innerHTML = `
<header class="border-b border-slate-800/80 pb-4">
  <div class="flex flex-wrap items-center justify-between gap-3">
    <div>
      <p class="text-[0.7rem] uppercase tracking-[0.18em] text-slate-400">
        ${post.category}
      </p>
      <h2 class="mt-1 text-2xl font-semibold tracking-tight text-slate-50 sm:text-3xl" style="font-family: 'Space Grotesk', system-ui, sans-serif;">
        ${post.title}
      </h2>
    </div>
    <div class="flex flex-col items-end gap-1 text-right text-[0.7rem] text-slate-400">
      <span>${post.meta}</span>
      <span>Published · Demo content</span>
    </div>
  </div>
</header>
<div class="prose prose-invert mt-4 max-w-none text-base leading-relaxed text-slate-200">
  ${post.content}
</div>
    `;
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  // Attach listeners
  const list = document.getElementById('blog-list');
  if (list) {
    list.addEventListener('click', (event) => {
      const target = (event.target as HTMLElement).closest('[data-post-id]');
      if (!target) return;
      const id = target.getAttribute('data-post-id');
      if (id) {
        renderPost(id);
      }
    });
  }

  // Optional: support hash-based navigation (#blog-2 etc.)
  function handleHash() {
    const id = window.location.hash.replace('#', '');
    if (id && posts[id]) {
      renderPost(id);
    }
  }
  window.addEventListener('hashchange', handleHash);
  handleHash();
</script>
